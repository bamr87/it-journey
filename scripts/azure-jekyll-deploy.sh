#!/usr/bin/env bash
#
# Script: azure-jekyll-deploy.sh
# Description: Complete automation for deploying Jekyll sites to Azure Static Web Apps
# Author: IT-Journey / Generated by Bash-It
# Version: 1.0.0
# Last Modified: 2025-11-17
# Dependencies: az, git, curl, jq
# Tested On: macOS 12+, Ubuntu 20.04+, WSL2
#
# Usage: azure-jekyll-deploy.sh [OPTIONS] [ARGUMENTS]
#        azure-jekyll-deploy.sh --help
#
# Exit Codes:
#   0 - Success
#   1 - General error
#   2 - Misuse of command (invalid arguments)
#   3 - Missing dependency
#   4 - Permission denied
#   5 - Configuration error
#   6 - Runtime error
#   7 - Azure operation failed
#   8 - GitHub operation failed
#   9 - Jekyll build failed

# Enable strict error handling
set -o errexit   # Exit on error (set -e)
set -o nounset   # Exit on undefined variable (set -u)
set -o pipefail  # Catch errors in pipes
# set -o xtrace  # Enable for debugging (set -x)

# Set safe defaults
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
export LANG="C"
export LC_ALL="C"
umask 0027  # Restrictive file creation mask

# Script metadata
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_PID=$$

# Runtime variables
readonly TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
readonly HOSTNAME="$(hostname -s)"

# Configuration (override via environment or config file)
: "${CONFIG_FILE:="${SCRIPT_DIR}/.${SCRIPT_NAME%.sh}.conf"}"
: "${LOG_DIR:="/var/log/${SCRIPT_NAME%.sh}"}"
: "${LOG_FILE:="${LOG_DIR}/${SCRIPT_NAME%.sh}_${TIMESTAMP}.log"}"
: "${TMP_DIR:="/tmp/${SCRIPT_NAME%.sh}_${SCRIPT_PID}"}"
: "${VERBOSE:=0}"
: "${DRY_RUN:=0}"
: "${INTERACTIVE:=1}"

# Azure-specific configuration
: "${AZURE_SUBSCRIPTION:=""}"
: "${AZURE_RESOURCE_GROUP:="jekyll-citadel-rg"}"
: "${AZURE_LOCATION:="EastUS"}"
: "${AZURE_APP_NAME:=""}"
: "${GITHUB_REPO:=""}"
: "${GITHUB_TOKEN:=""}"
: "${CUSTOM_DOMAIN:=""}"
: "${JEKYLL_SOURCE_DIR:="."}"

# Colors for terminal output (disable if not a TTY)
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly MAGENTA='\033[0;35m'
    readonly CYAN='\033[0;36m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly MAGENTA=''
    readonly CYAN=''
    readonly NC=''
fi

# Log levels
readonly LOG_LEVEL_DEBUG=0
readonly LOG_LEVEL_INFO=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_ERROR=3
readonly LOG_LEVEL_FATAL=4

# Default log level
: "${LOG_LEVEL:=${LOG_LEVEL_INFO}}"

#######################################
# Print message to stderr and log file
# Arguments:
#   $1 - Log level
#   $2+ - Message
#######################################
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"

    echo "[${timestamp}] [${level}] ${message}" >> "${LOG_FILE}" 2>/dev/null || true

    case "${level}" in
        DEBUG)
            [[ "${VERBOSE}" -eq 1 ]] && echo -e "${CYAN}[DEBUG]${NC} ${message}" >&2
            ;;
        INFO)
            echo -e "${GREEN}[INFO]${NC} ${message}" >&2
            ;;
        WARN)
            echo -e "${YELLOW}[WARN]${NC} ${message}" >&2
            ;;
        ERROR)
            echo -e "${RED}[ERROR]${NC} ${message}" >&2
            ;;
        FATAL)
            echo -e "${RED}[FATAL]${NC} ${message}" >&2
            ;;
    esac
}

log_debug() { log "DEBUG" "$@"; }
log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_fatal() { log "FATAL" "$@"; }

#######################################
# Display usage information
#######################################
usage() {
    cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}

Azure Jekyll Deployment Automation - Deploy Jekyll sites to Azure Static Web Apps

Description:
    Complete automation script for deploying Jekyll sites to Azure Static Web Apps.
    Follows the Azure Ascension quest workflow with comprehensive error handling,
    validation, and rollback capabilities.

Usage:
    ${SCRIPT_NAME} [OPTIONS] [COMMAND]

Commands:
    setup           Initial Azure and GitHub setup
    deploy          Full deployment pipeline (default)
    configure       Configure Jekyll site for Azure
    azure-create    Create Azure Static Web App
    github-workflow Setup GitHub Actions CI/CD
    domain-setup    Configure custom domain
    cleanup         Remove Azure resources

Options:
    -h, --help              Display this help message
    -v, --version           Display script version
    -V, --verbose           Enable verbose output
    -q, --quiet             Suppress non-error output
    -d, --dry-run           Show what would be done without doing it
    -c, --config FILE       Use alternate configuration file
    -l, --log-file FILE     Write logs to specified file
    -f, --force             Force operation (skip confirmations)
    -y, --yes               Answer yes to all prompts

    --subscription ID       Azure subscription ID
    --resource-group NAME   Azure resource group name (default: jekyll-citadel-rg)
    --location LOC          Azure region (default: EastUS)
    --app-name NAME         Azure Static Web App name
    --github-repo URL       GitHub repository URL
    --github-token TOKEN    GitHub personal access token
    --custom-domain DOMAIN  Custom domain to configure
    --jekyll-dir DIR        Jekyll source directory (default: .)

Arguments:
    [COMMAND]               Operation to perform (default: deploy)

Examples:
    # Interactive setup and deployment
    ${SCRIPT_NAME}

    # Deploy with custom configuration
    ${SCRIPT_NAME} --app-name my-jekyll-site --github-repo https://github.com/user/repo

    # Setup only (Azure and GitHub configuration)
    ${SCRIPT_NAME} setup

    # Dry-run to see what would be done
    ${SCRIPT_NAME} --dry-run --verbose

    # Configure custom domain
    ${SCRIPT_NAME} domain-setup --custom-domain www.example.com

    # Cleanup Azure resources
    ${SCRIPT_NAME} cleanup --force

Configuration File (~/.azure-jekyll-deploy.conf):
    AZURE_SUBSCRIPTION="your-subscription-id"
    AZURE_RESOURCE_GROUP="jekyll-citadel-rg"
    AZURE_LOCATION="EastUS"
    AZURE_APP_NAME="your-app-name"
    GITHUB_REPO="https://github.com/user/repo"
    GITHUB_TOKEN="your-github-token"
    CUSTOM_DOMAIN="www.example.com"
    JEKYLL_SOURCE_DIR="."

Exit Codes:
    0    Success
    1    General error
    2    Invalid arguments
    3    Missing dependency
    4    Permission denied
    5    Configuration error
    6    Runtime error
    7    Azure operation failed
    8    GitHub operation failed
    9    Jekyll build failed

For more information, see: https://it-journey.dev/quests/level-0082-azure-ascension-jekyll-deployment/

EOF
    exit 0
}

#######################################
# Display version information
#######################################
version() {
    echo "${SCRIPT_NAME} version ${SCRIPT_VERSION}"
    exit 0
}

#######################################
# Cleanup function called on EXIT
# Arguments:
#   None
# Globals:
#   TMP_DIR
#######################################
cleanup() {
    local exit_code=$?

    log_debug "Running cleanup (exit code: ${exit_code})"

    # Remove temporary directory
    if [[ -d "${TMP_DIR}" ]]; then
        rm -rf "${TMP_DIR}" 2>/dev/null || log_warn "Failed to remove temp dir: ${TMP_DIR}"
    fi

    # Add custom cleanup operations here

    if [[ ${exit_code} -eq 0 ]]; then
        log_info "Script completed successfully"
    else
        log_error "Script exited with code ${exit_code}"
    fi

    exit "${exit_code}"
}

#######################################
# Error handler called on ERR signal
# Arguments:
#   $1 - Line number where error occurred
#   $2 - Exit code
#######################################
error_handler() {
    local line_number="$1"
    local exit_code="${2:-1}"
    log_fatal "Error occurred at line ${line_number} (exit code: ${exit_code})"
    exit "${exit_code}"
}

# Set trap handlers
trap cleanup EXIT
trap 'error_handler ${LINENO} $?' ERR
trap 'log_warn "Received SIGINT"; exit 130' INT
trap 'log_warn "Received SIGTERM"; exit 143' TERM

#######################################
# Check if command exists
# Arguments:
#   $1 - Command name
# Returns:
#   0 if command exists, 1 otherwise
#######################################
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

#######################################
# Check for required commands
# Arguments:
#   $@ - List of required commands
# Exits:
#   3 if any command is missing
#######################################
require_commands() {
    local missing_commands=()

    for cmd in "$@"; do
        if ! command_exists "${cmd}"; then
            missing_commands+=("${cmd}")
        fi
    done

    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_fatal "Missing required commands: ${missing_commands[*]}"
        log_info "Please install missing dependencies and try again"
        log_info "For Azure CLI: https://docs.microsoft.com/cli/azure/install-azure-cli"
        exit 3
    fi
}

#######################################
# Confirm action with user (if interactive)
# Arguments:
#   $1 - Prompt message
# Returns:
#   0 if confirmed, 1 otherwise
#######################################
confirm() {
    local prompt="$1"

    # Skip confirmation if non-interactive or --yes flag
    if [[ "${INTERACTIVE}" -eq 0 ]] || [[ "${FORCE_YES:-0}" -eq 1 ]]; then
        return 0
    fi

    local response
    read -r -p "${prompt} [y/N] " response
    case "${response}" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

#######################################
# Create directory with error checking
# Arguments:
#   $1 - Directory path
#   $2 - Optional: permissions (default 0755)
#######################################
safe_mkdir() {
    local dir="$1"
    local perms="${2:-0755}"

    if [[ ! -d "${dir}" ]]; then
        log_debug "Creating directory: ${dir}"
        if [[ "${DRY_RUN}" -eq 0 ]]; then
            mkdir -p "${dir}" || {
                log_error "Failed to create directory: ${dir}"
                return 1
            }
            chmod "${perms}" "${dir}" || log_warn "Failed to set permissions on ${dir}"
        else
            log_info "[DRY-RUN] Would create directory: ${dir}"
        fi
    fi
}

#######################################
# Load configuration from file
# Arguments:
#   $1 - Config file path
# Globals:
#   Sets variables defined in config file
#######################################
load_config() {
    local config_file="$1"

    if [[ ! -f "${config_file}" ]]; then
        log_debug "Config file not found: ${config_file}"
        return 0
    fi

    log_info "Loading configuration from: ${config_file}"

    # Source config file in subshell for safety
    if ! (set -e; source "${config_file}"); then
        log_error "Failed to parse config file: ${config_file}"
        exit 5
    fi

    # Actually source it for real
    # shellcheck disable=SC1090
    source "${config_file}"

    log_debug "Configuration loaded successfully"
}

#######################################
# Validate configuration
# Returns:
#   0 if valid, exits with 5 if invalid
#######################################
validate_config() {
    local errors=0

    # Validate Azure configuration
    if [[ -n "${AZURE_APP_NAME}" ]] && [[ ! "${AZURE_APP_NAME}" =~ ^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$ ]]; then
        log_error "Configuration error: AZURE_APP_NAME must be 2-60 characters, alphanumeric and hyphens only"
        ((errors++))
    fi

    if [[ -n "${CUSTOM_DOMAIN}" ]] && [[ ! "${CUSTOM_DOMAIN}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        log_error "Configuration error: CUSTOM_DOMAIN is not a valid domain name"
        ((errors++))
    fi

    if [[ -n "${GITHUB_REPO}" ]] && [[ ! "${GITHUB_REPO}" =~ ^https://github\.com/[^/]+/[^/]+$ ]]; then
        log_error "Configuration error: GITHUB_REPO must be a valid GitHub HTTPS URL"
        ((errors++))
    fi

    if [[ ${errors} -gt 0 ]]; then
        log_fatal "Configuration validation failed with ${errors} error(s)"
        exit 5
    fi

    log_debug "Configuration validation passed"
}

#######################################
# Parse command-line arguments
# Arguments:
#   $@ - All command-line arguments
# Globals:
#   Sets global variables based on arguments
#######################################
parse_args() {
    # No arguments provided, show usage
    if [[ $# -eq 0 ]]; then
        usage
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                ;;
            -v|--version)
                version
                ;;
            -V|--verbose)
                VERBOSE=1
                LOG_LEVEL="${LOG_LEVEL_DEBUG}"
                log_debug "Verbose mode enabled"
                shift
                ;;
            -q|--quiet)
                QUIET=1
                LOG_LEVEL="${LOG_LEVEL_ERROR}"
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                log_info "Dry-run mode enabled"
                shift
                ;;
            -c|--config)
                CONFIG_FILE="$2"
                if [[ ! -f "${CONFIG_FILE}" ]]; then
                    log_fatal "Config file not found: ${CONFIG_FILE}"
                    exit 5
                fi
                shift 2
                ;;
            -l|--log-file)
                LOG_FILE="$2"
                shift 2
                ;;
            -f|--force)
                FORCE=1
                log_warn "Force mode enabled"
                shift
                ;;
            -y|--yes)
                FORCE_YES=1
                INTERACTIVE=0
                shift
                ;;
            --subscription)
                AZURE_SUBSCRIPTION="$2"
                shift 2
                ;;
            --resource-group)
                AZURE_RESOURCE_GROUP="$2"
                shift 2
                ;;
            --location)
                AZURE_LOCATION="$2"
                shift 2
                ;;
            --app-name)
                AZURE_APP_NAME="$2"
                shift 2
                ;;
            --github-repo)
                GITHUB_REPO="$2"
                shift 2
                ;;
            --github-token)
                GITHUB_TOKEN="$2"
                shift 2
                ;;
            --custom-domain)
                CUSTOM_DOMAIN="$2"
                shift 2
                ;;
            --jekyll-dir)
                JEKYLL_SOURCE_DIR="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Use --help for usage information"
                exit 2
                ;;
            *)
                # Positional arguments (commands)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done

    # Restore positional parameters
    set -- "${POSITIONAL_ARGS[@]}"

    log_debug "Argument parsing completed"
}

#######################################
# Validate runtime environment
# Returns:
#   0 if valid, exits on error
#######################################
validate_environment() {
    log_info "Validating environment..."

    # Check required commands
    local required_commands=(
        az
        git
        curl
        jq
    )

    require_commands "${required_commands[@]}"

    # Validate OS/platform
    local os_type="$(uname -s)"
    log_debug "Operating system: ${os_type}"

    case "${os_type}" in
        Linux*)
            log_debug "Linux system detected"
            ;;
        Darwin*)
            log_debug "macOS system detected"
            ;;
        CYGWIN*|MINGW*|MSYS*)
            log_debug "Windows system detected"
            ;;
        *)
            log_warn "Unknown operating system: ${os_type}"
            ;;
    esac

    # Create required directories
    safe_mkdir "${LOG_DIR}" 0755
    safe_mkdir "${TMP_DIR}" 0700

    # Load and validate configuration
    if [[ -f "${CONFIG_FILE}" ]]; then
        load_config "${CONFIG_FILE}"
    fi

    validate_config

    log_info "Environment validation passed"
}

#######################################
# Check Azure CLI login status
# Returns:
#   0 if logged in, 1 otherwise
#######################################
check_azure_login() {
    if az account show >/dev/null 2>&1; then
        log_debug "Azure CLI is logged in"
        return 0
    else
        log_debug "Azure CLI is not logged in"
        return 1
    fi
}

#######################################
# Login to Azure
# Returns:
#   0 on success, 7 on failure
#######################################
azure_login() {
    log_info "Logging into Azure..."

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        if ! az login --use-device-code; then
            log_error "Azure login failed"
            return 7
        fi

        if [[ -n "${AZURE_SUBSCRIPTION}" ]]; then
            if ! az account set --subscription "${AZURE_SUBSCRIPTION}"; then
                log_error "Failed to set Azure subscription"
                return 7
            fi
        fi

        log_info "Azure login successful"
    else
        log_info "[DRY-RUN] Would login to Azure"
    fi

    return 0
}

#######################################
# Create Azure resource group
# Returns:
#   0 on success, 7 on failure
#######################################
create_resource_group() {
    log_info "Creating Azure resource group: ${AZURE_RESOURCE_GROUP}"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        if ! az group create \
            --name "${AZURE_RESOURCE_GROUP}" \
            --location "${AZURE_LOCATION}"; then
            log_error "Failed to create resource group"
            return 7
        fi

        log_info "Resource group created successfully"
    else
        log_info "[DRY-RUN] Would create resource group: ${AZURE_RESOURCE_GROUP}"
    fi

    return 0
}

#######################################
# Create Azure Static Web App
# Returns:
#   0 on success, 7 on failure
#######################################
create_static_web_app() {
    local app_name="$1"
    local repo_url="$2"

    log_info "Creating Azure Static Web App: ${app_name}"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        if ! az staticwebapp create \
            --name "${app_name}" \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --location "${AZURE_LOCATION}" \
            --source "${repo_url}" \
            --branch "main" \
            --app-location "/" \
            --output-location "_site" \
            --login-with-github; then
            log_error "Failed to create Static Web App"
            return 7
        fi

        log_info "Static Web App created successfully"
    else
        log_info "[DRY-RUN] Would create Static Web App: ${app_name}"
    fi

    return 0
}

#######################################
# Get Azure Static Web App deployment token
# Arguments:
#   $1 - App name
# Returns:
#   Token on stdout, 7 on failure
#######################################
get_deployment_token() {
    local app_name="$1"

    log_debug "Retrieving deployment token for: ${app_name}"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        local token
        token=$(az staticwebapp secrets list \
            --name "${app_name}" \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --query "properties.apiKey" \
            --output tsv)

        if [[ -z "${token}" ]]; then
            log_error "Failed to retrieve deployment token"
            return 7
        fi

        echo "${token}"
    else
        log_info "[DRY-RUN] Would retrieve deployment token"
        echo "fake-token-for-dry-run"
    fi

    return 0
}

#######################################
# Configure Jekyll site for Azure
# Arguments:
#   $1 - Jekyll source directory
# Returns:
#   0 on success, 9 on failure
#######################################
configure_jekyll_site() {
    local jekyll_dir="$1"

    log_info "Configuring Jekyll site for Azure deployment"

    # Change to Jekyll directory
    cd "${jekyll_dir}" || {
        log_error "Failed to change to Jekyll directory: ${jekyll_dir}"
        return 9
    }

    # Update _config.yml
    local config_file="_config.yml"
    if [[ -f "${config_file}" ]]; then
        log_info "Updating Jekyll configuration"

        if [[ "${DRY_RUN}" -eq 0 ]]; then
            # Add Azure-specific configuration
            cat >> "${config_file}" << 'EOF'

# Azure Static Web Apps Configuration
url: "https://REPLACE_WITH_APP_NAME.azurestaticapps.net"
baseurl: ""

# Performance optimizations
compress_html:
  clippings: all
  comments: ["<!-- ", " -->"]
  endings: all
  startings: [html, head, body]

# Exclude development files
exclude:
  - .bundle/
  - .sass-cache/
  - .jekyll-cache/
  - gemfiles/
  - vendor/
  - .github/
  - scripts/
EOF

            log_info "Jekyll configuration updated"
        else
            log_info "[DRY-RUN] Would update Jekyll configuration"
        fi
    else
        log_warn "No _config.yml found, skipping configuration update"
    fi

    # Test Jekyll build
    log_info "Testing Jekyll build"
    if [[ "${DRY_RUN}" -eq 0 ]]; then
        if ! bundle exec jekyll build --quiet; then
            log_error "Jekyll build failed"
            return 9
        fi
        log_info "Jekyll build successful"
    else
        log_info "[DRY-RUN] Would test Jekyll build"
    fi

    return 0
}

#######################################
# Create GitHub Actions workflow
# Arguments:
#   $1 - GitHub repository URL
#   $2 - Deployment token
# Returns:
#   0 on success, 8 on failure
#######################################
create_github_workflow() {
    local repo_url="$1"
    local deploy_token="$2"

    log_info "Setting up GitHub Actions workflow"

    # Extract repo info from URL
    local repo_owner repo_name
    repo_owner=$(echo "${repo_url}" | sed -n 's|https://github.com/\([^/]*\)/\([^/]*\)$|\1|p')
    repo_name=$(echo "${repo_url}" | sed -n 's|https://github.com/\([^/]*\)/\([^/]*\)$|\2|p')

    if [[ -z "${repo_owner}" ]] || [[ -z "${repo_name}" ]]; then
        log_error "Failed to parse GitHub repository URL"
        return 8
    fi

    # Create .github/workflows directory
    safe_mkdir ".github/workflows"

    # Create workflow file
    local workflow_file=".github/workflows/azure-static-web-apps.yml"

    log_info "Creating GitHub Actions workflow file"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        cat > "${workflow_file}" << EOF
name: Azure Static Web Apps CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, closed]
    branches:
      - main

jobs:
  build_and_deploy_job:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    runs-on: ubuntu-latest
    name: Build and Deploy Job
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0
      
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true
      
      - name: Install dependencies
        run: bundle install
      
      - name: Build Jekyll site
        run: bundle exec jekyll build --config _config.yml
      
      - name: Deploy to Azure Static Web Apps
        id: builddeploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: \${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: \${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "/"
          api_location: ""
          output_location: "_site"
          skip_app_build: true

  close_pull_request_job:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request Job
    steps:
      - name: Close pull request
        id: closepullrequest
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: \${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: \${{ secrets.GITHUB_TOKEN }}
          action: "close"
EOF

        log_info "GitHub Actions workflow created"

        # Add deployment token to GitHub secrets (requires GitHub CLI or manual setup)
        if command_exists gh; then
            log_info "Setting up GitHub secret for deployment token"
            if [[ -n "${GITHUB_TOKEN}" ]]; then
                if ! echo "${deploy_token}" | gh secret set AZURE_STATIC_WEB_APPS_API_TOKEN --repo "${repo_owner}/${repo_name}"; then
                    log_warn "Failed to set GitHub secret automatically. Please set it manually:"
                    log_warn "Repository: https://github.com/${repo_owner}/${repo_name}/settings/secrets/actions"
                    log_warn "Secret Name: AZURE_STATIC_WEB_APPS_API_TOKEN"
                    log_warn "Secret Value: ${deploy_token}"
                fi
            else
                log_warn "GitHub token not provided. Please set the deployment token manually:"
                log_warn "Repository: https://github.com/${repo_owner}/${repo_name}/settings/secrets/actions"
                log_warn "Secret Name: AZURE_STATIC_WEB_APPS_API_TOKEN"
                log_warn "Secret Value: ${deploy_token}"
            fi
        else
            log_warn "GitHub CLI not found. Please set the deployment token manually:"
            log_warn "Repository: https://github.com/${repo_owner}/${repo_name}/settings/secrets/actions"
            log_warn "Secret Name: AZURE_STATIC_WEB_APPS_API_TOKEN"
            log_warn "Secret Value: ${deploy_token}"
        fi

    else
        log_info "[DRY-RUN] Would create GitHub Actions workflow"
    fi

    return 0
}

#######################################
# Setup custom domain
# Arguments:
#   $1 - App name
#   $2 - Custom domain
# Returns:
#   0 on success, 7 on failure
#######################################
setup_custom_domain() {
    local app_name="$1"
    local domain="$2"

    log_info "Setting up custom domain: ${domain}"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        # Validate domain
        if ! az staticwebapp hostname validate \
            --name "${app_name}" \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --domain "${domain}"; then
            log_error "Domain validation failed"
            return 7
        fi

        # Set custom domain
        if ! az staticwebapp hostname set \
            --name "${app_name}" \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --domain "${domain}"; then
            log_error "Failed to set custom domain"
            return 7
        fi

        log_info "Custom domain configured successfully"
        log_info "Note: DNS propagation may take up to 48 hours"
    else
        log_info "[DRY-RUN] Would setup custom domain: ${domain}"
    fi

    return 0
}

#######################################
# Cleanup Azure resources
# Returns:
#   0 on success, 7 on failure
#######################################
cleanup_azure_resources() {
    log_warn "Cleaning up Azure resources"

    if [[ "${DRY_RUN}" -eq 0 ]]; then
        if ! confirm "This will delete the resource group '${AZURE_RESOURCE_GROUP}' and all resources within it. Continue?"; then
            log_info "Cleanup cancelled by user"
            return 0
        fi

        if ! az group delete \
            --name "${AZURE_RESOURCE_GROUP}" \
            --yes \
            --no-wait; then
            log_error "Failed to delete resource group"
            return 7
        fi

        log_info "Azure resources cleanup initiated"
        log_info "Note: Resource deletion may take several minutes to complete"
    else
        log_info "[DRY-RUN] Would cleanup Azure resources"
    fi

    return 0
}

#######################################
# Setup command - Initial Azure and GitHub configuration
# Returns:
#   0 on success, non-zero on failure
#######################################
cmd_setup() {
    log_info "Starting Azure Jekyll deployment setup"

    # Check Azure login
    if ! check_azure_login; then
        if ! azure_login; then
            return 7
        fi
    fi

    # Create resource group
    if ! create_resource_group; then
        return 7
    fi

    # Configure Jekyll site
    if ! configure_jekyll_site "${JEKYLL_SOURCE_DIR}"; then
        return 9
    fi

    log_info "Setup completed successfully"
    log_info "Next steps:"
    log_info "1. Create a GitHub repository for your Jekyll site"
    log_info "2. Push your code to GitHub"
    log_info "3. Run: ${SCRIPT_NAME} deploy --github-repo <your-repo-url>"

    return 0
}

#######################################
# Deploy command - Full deployment pipeline
# Returns:
#   0 on success, non-zero on failure
#######################################
cmd_deploy() {
    log_info "Starting full Azure Jekyll deployment"

    # Validate required parameters
    if [[ -z "${AZURE_APP_NAME}" ]]; then
        log_error "Azure app name is required. Use --app-name or set AZURE_APP_NAME"
        return 2
    fi

    if [[ -z "${GITHUB_REPO}" ]]; then
        log_error "GitHub repository URL is required. Use --github-repo or set GITHUB_REPO"
        return 2
    fi

    # Check Azure login
    if ! check_azure_login; then
        if ! azure_login; then
            return 7
        fi
    fi

    # Create resource group
    if ! create_resource_group; then
        return 7
    fi

    # Create Static Web App
    if ! create_static_web_app "${AZURE_APP_NAME}" "${GITHUB_REPO}"; then
        return 7
    fi

    # Get deployment token
    local deploy_token
    if ! deploy_token=$(get_deployment_token "${AZURE_APP_NAME}"); then
        return 7
    fi

    # Configure Jekyll site
    if ! configure_jekyll_site "${JEKYLL_SOURCE_DIR}"; then
        return 9
    fi

    # Create GitHub workflow
    if ! create_github_workflow "${GITHUB_REPO}" "${deploy_token}"; then
        return 8
    fi

    # Setup custom domain if provided
    if [[ -n "${CUSTOM_DOMAIN}" ]]; then
        if ! setup_custom_domain "${AZURE_APP_NAME}" "${CUSTOM_DOMAIN}"; then
            log_warn "Custom domain setup failed, but deployment continues"
        fi
    fi

    log_info "Deployment completed successfully!"
    log_info "Your Jekyll site is now deployed to: https://${AZURE_APP_NAME}.azurestaticapps.net"
    if [[ -n "${CUSTOM_DOMAIN}" ]]; then
        log_info "Custom domain (when DNS propagates): https://${CUSTOM_DOMAIN}"
    fi
    log_info "GitHub Actions will automatically deploy future changes"

    return 0
}

#######################################
# Configure command - Configure Jekyll site only
# Returns:
#   0 on success, 9 on failure
#######################################
cmd_configure() {
    log_info "Configuring Jekyll site for Azure"

    if ! configure_jekyll_site "${JEKYLL_SOURCE_DIR}"; then
        return 9
    fi

    log_info "Jekyll configuration completed"
    return 0
}

#######################################
# Azure create command - Create Azure resources only
# Returns:
#   0 on success, 7 on failure
#######################################
cmd_azure_create() {
    log_info "Creating Azure Static Web App"

    # Validate required parameters
    if [[ -z "${AZURE_APP_NAME}" ]]; then
        log_error "Azure app name is required. Use --app-name or set AZURE_APP_NAME"
        return 2
    fi

    if [[ -z "${GITHUB_REPO}" ]]; then
        log_error "GitHub repository URL is required. Use --github-repo or set GITHUB_REPO"
        return 2
    fi

    # Check Azure login
    if ! check_azure_login; then
        if ! azure_login; then
            return 7
        fi
    fi

    # Create resource group
    if ! create_resource_group; then
        return 7
    fi

    # Create Static Web App
    if ! create_static_web_app "${AZURE_APP_NAME}" "${GITHUB_REPO}"; then
        return 7
    fi

    # Get and display deployment token
    local deploy_token
    if ! deploy_token=$(get_deployment_token "${AZURE_APP_NAME}"); then
        return 7
    fi

    log_info "Azure Static Web App created successfully"
    log_info "App URL: https://${AZURE_APP_NAME}.azurestaticapps.net"
    log_info "Deployment Token: ${deploy_token}"
    log_info "Use this token to configure GitHub Actions"

    return 0
}

#######################################
# GitHub workflow command - Setup CI/CD only
# Returns:
#   0 on success, 8 on failure
#######################################
cmd_github_workflow() {
    log_info "Setting up GitHub Actions workflow"

    # Validate required parameters
    if [[ -z "${GITHUB_REPO}" ]]; then
        log_error "GitHub repository URL is required. Use --github-repo or set GITHUB_REPO"
        return 2
    fi

    # For this command, we need the deployment token as an argument or from config
    local deploy_token="${AZURE_STATIC_WEB_APPS_API_TOKEN:-}"

    if [[ -z "${deploy_token}" ]]; then
        log_error "Deployment token is required. Use AZURE_STATIC_WEB_APPS_API_TOKEN environment variable"
        log_error "Or run 'azure-create' command first to get the token"
        return 2
    fi

    if ! create_github_workflow "${GITHUB_REPO}" "${deploy_token}"; then
        return 8
    fi

    log_info "GitHub Actions workflow setup completed"
    return 0
}

#######################################
# Domain setup command - Configure custom domain
# Returns:
#   0 on success, 7 on failure
#######################################
cmd_domain_setup() {
    log_info "Setting up custom domain"

    # Validate required parameters
    if [[ -z "${AZURE_APP_NAME}" ]]; then
        log_error "Azure app name is required. Use --app-name or set AZURE_APP_NAME"
        return 2
    fi

    if [[ -z "${CUSTOM_DOMAIN}" ]]; then
        log_error "Custom domain is required. Use --custom-domain or set CUSTOM_DOMAIN"
        return 2
    fi

    # Check Azure login
    if ! check_azure_login; then
        if ! azure_login; then
            return 7
        fi
    fi

    if ! setup_custom_domain "${AZURE_APP_NAME}" "${CUSTOM_DOMAIN}"; then
        return 7
    fi

    log_info "Custom domain setup completed"
    return 0
}

#######################################
# Cleanup command - Remove Azure resources
# Returns:
#   0 on success, 7 on failure
#######################################
cmd_cleanup() {
    log_info "Starting Azure resources cleanup"

    # Check Azure login
    if ! check_azure_login; then
        if ! azure_login; then
            return 7
        fi
    fi

    if ! cleanup_azure_resources; then
        return 7
    fi

    log_info "Cleanup completed"
    return 0
}

#######################################
# Main business logic function
# Arguments:
#   $@ - Processed arguments
# Returns:
#   0 on success, non-zero on failure
#######################################
execute_core_logic() {
    local command="${1:-deploy}"

    log_info "Executing command: ${command}"

    case "${command}" in
        setup)
            cmd_setup
            ;;
        deploy)
            cmd_deploy
            ;;
        configure)
            cmd_configure
            ;;
        azure-create)
            cmd_azure_create
            ;;
        github-workflow)
            cmd_github_workflow
            ;;
        domain-setup)
            cmd_domain_setup
            ;;
        cleanup)
            cmd_cleanup
            ;;
        *)
            log_error "Unknown command: ${command}"
            log_info "Available commands: setup, deploy, configure, azure-create, github-workflow, domain-setup, cleanup"
            return 2
            ;;
    esac
}

#######################################
# Main function - orchestrates script execution
# Arguments:
#   $@ - All command-line arguments
# Returns:
#   0 on success, non-zero on failure
#######################################
main() {
    # Initialize logging
    safe_mkdir "$(dirname "${LOG_FILE}")" 0755
    log_info "=== ${SCRIPT_NAME} v${SCRIPT_VERSION} started ==="
    log_info "PID: ${SCRIPT_PID} | Hostname: ${HOSTNAME} | Timestamp: ${TIMESTAMP}"

    # Parse arguments
    local -a POSITIONAL_ARGS=()
    parse_args "$@"

    # Validate environment and dependencies
    validate_environment

    # Display dry-run warning
    if [[ "${DRY_RUN}" -eq 1 ]]; then
        log_warn "==================================="
        log_warn "DRY-RUN MODE: No changes will be made"
        log_warn "==================================="
    fi

    # Execute core logic
    execute_core_logic "${POSITIONAL_ARGS[@]}"

    # Success
    return 0
}

# Entry point: call main with all arguments
main "$@"